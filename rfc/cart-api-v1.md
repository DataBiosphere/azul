# Version 1

| Issue | Status |
| ----- | ------ |
| #88   | Draft  |

## Data Models

See [Data Models](cart-api-models.md).

## Web API Specification

Please note that:
1. All endpoints are protected by **a bearer token** ([RFC 6750](https://tools.ietf.org/html/rfc6750)).
  * For the initial release,
    * the bearer token can be anything that we use to identify a user *until the web service integrates with the auth service (`https://auth.{DEPLOYMENT_STAGE}.data.humancellatlas.org`, [docs](https://allspark.dev.data.humancellatlas.org/dcp-ops/docs/wikis/Security/Authentication%20and%20Authorization/Setting%20up%20DCP%20Auth))*, and
    * the client will generate a version 4 UUID string as dubbed as session ID (and the backend will treat the session ID as user ID) and the base64-encoded string of that UUID will be a bearer token.

2. For CRUD endpoints,
  * All CRUD endpoints take JSON request body on `POST` and `PUT`/`PATCH` requests.
  * `id` is not required as either the ID will be auto-generated by the endpoint on `POST` request, or the ID is given on the URL and immutable on `PUT`/`PATCH` request.
  * Generally, the response on `GET` request will return a single JSON object of the corresponding model if the ID is specified or the list of JSON object otherwise. *There will be some exceptions.*
  * For `PUT` and `PATCH` requests, if `id` in the URL path and `id` in the request body are different, the endpoint may respond with **HTTP 412** without doing anything (preferred), or **HTTP 200** without updating the ID of the corresponding entity.

3. Generally, all endpoints may respond different HTTP status codes according to the given scenario, unless specified otherwise.

| HTTP Status Code | Condition | Notes |
| --- | --- | --- |
| 200 | Everything is ok. | Default status code |
| 401 | The bearer token is invalid or not present. | - |
| 404 | Resource not found | Used on `GET` and `PUT` only |
| 405 | Method not allowed | AWS API Gateway will handle this automatically. |
| 409 | Data integrity error, e.g., supposing that item `i_1` is in cart `c_1`, the client mistakenly request to delete item `i_1` from cart `c_2`. | This is more commonly used in `PUT` and `DELETE` requests. |
| 410 | Resource no longer existed | Used on `DELETE` only |
| 412 | Invalid input / precondition failed | Requires input validation |

### CRUD APIs for `Cart`

| Method | Path | Description |
| --- | --- | --- |
| `POST` | `/resources/carts/` | Create a new (non-default) cart |
| `GET` | `/resources/carts/` | Retrieve a list of carts |
| `GET` | `/resources/carts/{id}` | Retrieve a single cart (see more detail below) |
| `PUT` | `/resources/carts/{id}` | Update the cart (see more detail below) |
| `DELETE` | `/resources/carts/{id}` | Delete a single cart (see more detail below) |

#### `GET /resources/carts/{id}`

Retrieve a single cart.

##### Response

Instead of returning `Cart` information, the response will be also returning the list of associated `CartItem`, as shown below:

```javascript
{
    id: str, // Cart ID
    cart_name: str,
    default: bool,
    items: List[CartItem] // Each CartItem object will not have `cart_id`.
}
```

##### Default Cart

The default cart is a special case and will be given back to the client ONLY IF `id` is `default` (all lowercase).

* `default` is **the alias ID** of the default cart belonging to the session user.
  * The actual ID of default cart will be returned in the response body.
  * This ID is only used in this endpoint.
* When the default cart is not available, the default cart will be created and return in the same request.

Here is the pseudo code for the request handler.

```python
# Pseudo code: Request Handler
def retrieve_one_cart(id: UUID):
    # Define: bearer_token is the request bearer token
    if id == 'default':
        cart = cart_repository.get_default(user_id = bearer_token)

        if not cart:
            # Either this or: cart = cart_repository.create(user_id = bearer_token, cart_name = '')
            cart = cart_repository.create(user_id = bearer_token, cart_name = '', default = True)
    else:
        cart = cart_repository.get(id)

    return dict(id=cart.id,
                cart_name=cart.cart_name,
                entity_type=cart.entity_type,
                default=cart.default,
                items=cart_item_repository.find_many_by_cart_id(cart.id))
```

Here is the sample request.

```
GET /resources/carts/default
Authorization: Bearer 261e1aea-82c9-4e38-a879-e2e02ef236a5
```

Here is the sample response.

```javascript
{
    id: "6b801de6-11d4-46c0-aed1-ca2110aa7d3c"
    cart_name: "",
    default: true,
    items: [...]
}
```

#### `PUT /resources/carts/{id}`

Here is the request body.

```javascript
{
    cart_name: str // Required
}
```

and the response is basically the JSON representation of `Cart`.

#### `DELETE /resources/carts/{id}`

* The endpoint will delete the target cart and respond with **HTTP 200** only if the cart belongs to the user making the request.
  * Otherwise, the endpoint will respond with **HTTP 403**.
* The endpoint will respond **HTTP 404** if the cart is not found.

### CRUD APIs for `CartItem`

| Method | Path | Description |
| --- | --- | --- |
| `POST` | `/resources/carts/{cart_id}/items/` | Create a new cart item |
| `DELETE` | `/resources/carts/{cart_id}/items/{id}` | Delete a single cart item |

#### `POST /resources/carts/{cart_id}/items/`

| Param Type | Param Name | Association |
| --- | --- | --- |
| URL Path | `cart_id` | `Cart.id` |

* The request body will be similar to `CartItem` without `cart_id`.
* The endpoint will also respond **HTTP 404** if the corresponding cart is not found.

> May need a new field to store SHA1 hash on the item data for quick check.

#### `DELETE /resources/carts/{cart_id}/items/{item_id}`

| Param Type | Param Name | Association |
| --- | --- | --- |
| URL Path | `cart_id` | `Cart.id` |
| URL Path | `item_id` | `CartItem.id` |

* The endpoint will also respond **HTTP 404** if the corresponding cart is not found.

### Other APIs

#### `POST /resources/carts/{cart_id}/items/query`

Save the cart items in batch by query.

| Param Type | Param Name | Association |
| --- | --- | --- |
| URL Path | `cart_id` | `Cart.id` |

TL;DR:
* Respond **HTTP 202** on successfully accepting a request.
* Use `POST /resources/cart-item-batch-jobs/{job_id}` to check the async job status.

The response body for HTTP 202 will be `CartItemBatchJob`.

##### Technical Considerations

As this operation may require more than 30 seconds to run, the batch operation is divided into three major parts: processing requests, job updates, and job reports.

> See [the overall diagram describing the process](https://github.com/DataBiosphere/azul/raw/rfc/cart-api/rfc/DNAstack%20-%20General%20-%20Batch%20Cart%20Item%20Creation%20API%20Diagram.png).

###### Processing requests

> See "Creation Request" in the diagram.

When the endpoint `λ1` receives a request with filters, the endpoint will delegate the query to `λ2` via **the request queue**. At this point, the client will not be able to figure out whether the new cart items based on the query are in the cart. The client will have to track the progress by sending request to `λ5` for an update.

> This is to offload querying ElasticSearch and publishing message to **the job part queue** to `λ2` as publishing messages seems to take a long time to finish.

> Also, either `λ1` or `λ2` will first the total number of hits so that the status check part can tell whether or not the batch job is done.

When `λ2` receives a message with a requested filter, it will run the query, iterate the result and send a list of ready-to-write `CartItem` to `λ3` (in multiple batches) via **the job part queue**.

> With [the size limit on SQS](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-limits.html), the message publication will be more frequent than ES scanning.

Then, for each batch, `λ3` will put each ready-to-write `CartItem` to DynamoDB. At the end of each batch, `λ3` will notify `λ4` that it finished writing the given batch via **the job part complete notification queue**.

###### job Updates

For each notice in **the job part complete notification queue**, `λ4` will either create a new `CartItemBatchJob` or try to update the corresponding one with the updated number of remaining parts.

> **The job part complete notification queue** is a FIFO queue to minimize race condition.

> The approach to avoid race conditions is based on [the doc on optimistic locking for DynamoDB with Java](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBMapper.OptimisticLocking.html) and [the use of `ConditionExpression` in `DynamoDBResource.put_item`](https://github.com/boto/boto3/issues/1550) where `CartItemBatchJob.remaining_parts` is acting as version.

###### Job Reports

The client at any time may send a request to `λ5` (`POST /resources/cart-item-batch-jobs/{job_id}`) to see the progress.

#### `POST /resources/cart-item-batch-jobs/{job_id}`

Get the status of the job.

| Param Type | Param Name | Association |
| --- | --- | --- |
| URL Path | `job_id` | `CartItemBatchJob.id` |

* Respond with HTTP 200 and the associated `CartItemBatchJob` if found.
* Respond with HTTP 404 otherwise.