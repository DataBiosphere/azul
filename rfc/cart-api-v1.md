# Version 1

| Issue | Status |
| ----- | ------ |
| #88   | Draft  |

## Data Models

See [Data Models](cart-api-models.md).

## Web API Specification

Please note that:
1. All endpoints are protected by **a bearer token** ([RFC 6750](https://tools.ietf.org/html/rfc6750)).
  * For the initial release,
    * the bearer token can be anything that we use to identify a user *until the web service integrates with the auth service (`https://auth.{DEPLOYMENT_STAGE}.data.humancellatlas.org`, [docs](https://allspark.dev.data.humancellatlas.org/dcp-ops/docs/wikis/Security/Authentication%20and%20Authorization/Setting%20up%20DCP%20Auth))*, and
    * the client will generate a version 4 UUID string as dubbed as session ID (and the backend will treat the session ID as user ID) and the base64-encoded string of that UUID will be a bearer token.

2. For CRUD endpoints,
  * All CRUD endpoints take JSON request body on `POST` and `PUT`/`PATCH` requests.
  * `id` is not required as either the ID will be auto-generated by the endpoint on `POST` request, or the ID is given on the URL and immutable on `PUT`/`PATCH` request.
  * Generally, the response on `GET` request will return a single JSON object of the corresponding model if the ID is specified or the list of JSON object otherwise. *There will be some exceptions.*
  * For `PUT` and `PATCH` requests, if `id` in the URL path and `id` in the request body are different, the endpoint may respond with **HTTP 412** without doing anything (preferred), or **HTTP 200** without updating the ID of the corresponding entity.

3. Generally, all endpoints may respond different HTTP status codes according to the given scenario, unless specified otherwise.

| HTTP Status Code | Condition | Notes |
| --- | --- | --- |
| 200 | Everything is ok. | Default status code |
| 401 | The bearer token is invalid or not present. | - |
| 404 | Resource not found | Used on `GET` and `PUT` only |
| 405 | Method not allowed | AWS API Gateway will handle this automatically. |
| 409 | Data integrity error, e.g., supposing that item `i_1` is in cart `c_1`, the client mistakenly request to delete item `i_1` from cart `c_2`. | This is more commonly used in `PUT` and `DELETE` requests. |
| 410 | Resource no longer existed | Used on `DELETE` only |
| 412 | Invalid input / precondition failed | Requires input validation |

API endpoints can be found in [cart-api-endpoint.md](cart-api-endpoints.md)

### CRUD APIs for `Cart`

| Method | Path | Description |
| --- | --- | --- |
| `POST` | `/resources/carts/` | Create a new (non-default) cart |
| `GET` | `/resources/carts/` | Retrieve a list of carts |
| `GET` | `/resources/carts/{id}` | Retrieve a single cart |
| `PUT` | `/resources/carts/{id}` | Update the cart |
| `DELETE` | `/resources/carts/{id}` | Delete a single cart |

### CRUD APIs for `CartItem`

| Method | Path | Description |
| --- | --- | --- |
| `POST` | `/resources/carts/{cart_id}/items` | Add an item to a cart |
| `GET` | `/resources/carts/{cart_id}/items` | Retrieve all items in the given cart |
| `DELETE` | `/resources/carts/{cart_id}/items/{item_id}` | Delete an item from the cart |
| `POST` | `/resources/carts/{cart_id}/items/batch` | Add all items matching the given filters to a cart |

## Default Cart - *TODO*

The default cart is a special case and will be given back to the client ONLY IF `id` is `default` (all lowercase).

* `default` is **the alias ID** of the default cart belonging to the session user.
  * The actual ID of default cart will be returned in the response body.
  * This ID is only used in this endpoint.
* When the default cart is not available, the default cart will be created and return in the same request.

Here is the pseudo code for the request handler.

```python
# Pseudo code: Request Handler
def retrieve_one_cart(id: UUID):
    # Define: bearer_token is the request bearer token
    if id == 'default':
        cart = cart_repository.get_default(user_id = bearer_token)

        if not cart:
            # Either this or: cart = cart_repository.create(user_id = bearer_token, cart_name = '')
            cart = cart_repository.create(user_id = bearer_token, cart_name = '', default = True)
    else:
        cart = cart_repository.get(id)

    return dict(id=cart.id,
                cart_name=cart.cart_name,
                entity_type=cart.entity_type,
                default=cart.default,
                items=cart_item_repository.find_many_by_cart_id(cart.id))
```

Here is the sample request.

```
GET /resources/carts/default
Authorization: Bearer 261e1aea-82c9-4e38-a879-e2e02ef236a5
```

Here is the sample response.

```javascript
{
    id: "6b801de6-11d4-46c0-aed1-ca2110aa7d3c"
    cart_name: "",
    default: true,
    items: [...]
}
```

## Export to DSS Collection - *TODO*

Carts can be exported to the DSS Collection via the `POST /resources/carts/{cart_id}/export` endpoint.
This endpoint will make use of `PUT /collections` in the DSS API corresponding to the matching environment 
(dev, staging, integration, prod).

The collection will look like:
```json
{
    "contents": [
        {
          "type": "files",
          "uuid": "ec4b742d-816b-4029-8194-418f714cd05d"
        },
        ...
    ],
    "description": "Exported cart f0734d85-f098-488f-b2cb-6e59dc20a65a",
    "details": {},
    "name": "Cart Name"
}
```

When a cart is exported, an attribute `CollectionId` is added to the cart in DynamoDB.
This attribute is the UUID of the latest exported collection of the cart.

If a cart is exported again, it will create a new collection and the `CollectionId` will be updated.

## Batch cart item write

The batch cart item write is executed by a step function state machine that is triggered by the 
`POST /resources/carts/{cart_id}/items/batch` endpoint.  This is to avoid both the 30 second limit
imposed by API Gateway and the 15 minute limit of a single Lambda execution.  This implementation
also allows for a simple method to monitor the status of ongoing writes (can check the status of an execution).

Filters and an entity type are given to `POST /resources/carts/{cart_id}/items/batch`.
The endpoint will start a state machine execution and immediately return the number
of items that will be written and a URL to send a GET request to in order to check the
status of the write.

The status check endpoint is `GET /resources/carts/status/{token}`.
`token` is a base64-encoded JSON containing the ID of the state machine execution.

If the write is still ongoing, the endpoint will return a flag indicating "not done" and
a URL at which the status can be rechecked.  e.g.:
```
{
    "done": false,
    "statusUrl": "https://status.url/resources/carts/status/{token}"
}
```

If the write is finished (or errored), the endpoint will return a flag indicating "done" 
and a flag indicating if the write was successful.  e.g.: 
```
{
    "done": true,
    "success": true
}
```  

#### State machine

The step function state machine consists of the states

State machine visualization:

![State machine visualization](state_machine.png)

The input of the state machine is:

```json
{
    "filters" : { ... },
    "entity_type" : str,
    "cart_id" : str,
    "item_count" : int,
    "batch_size" : int
}
```

The `WriteBatch` state will write up to `batch_size` items to DynamoDB and output the input, 
as well as pagination information (`search_after`) for Elasticsearch and the number of items 
that were written.

The `NextBatch` state will check the number of items that were written in the previous state.
- If the number is 0, that means all items have been written and the state will transition to
the `SuccessState`.
- If the number is not 0, then the state will transition to `WriteBatch` to continue writing
items starting at the given `search_after` position.

The `SuccessState` will end the execution with a success.

#### Limitations:

Because this implementation uses Elasticsearch search after for retrieving each batch, 
if the underlying data is changed in the middle of a write job (e.g. matching entities 
are added or deleted), then the resulting written cart items may not exactly match
the query results the user sees.

## TODO

- Default cart behaviour is not implemented
- Only one bundle is associated with each cart item but a project or specimen may have multiple bundles
- Export to DSS Collection API
- Authentication
