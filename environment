# This file uses Bash Here Documents that have to be indented with tabs so we
# uniformly use tabs for unaligned indent and tabs followed by spaces for
# aligned indent.

project_root="$(cd -P "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export project_root

# A little helper to make re-sourcing this script easier.
#
_refresh() {
	source "${project_root}/environment"
}

# Manage the symlink to the active deployment
#
_select() {
	if [[ $1 != "" ]]; then
		_deauth
		_link "$1" || return
		_refresh
		_preauth
	fi
	(cd "${project_root}/deployments" && ls -l .active)
}

_deselect() {
	_deauth
	rm "${project_root}/deployments/.active"
	_refresh
}

_link() {
	(
		cd "${project_root}/deployments" &&
			test -d "$1" &&
			{ [ ! -e .active ] || { [ -L .active ] && rm .active; }; } &&
			ln -s "$1" .active
	) || { echo error: "$1" && return; }
}

# Get temporary credentials from STS via AssumeRole and inject them
# into the current environment where other AWS client libraries can
# find them.
#
# https://github.com/boto/boto3/issues/1179#issuecomment-569940530
#
_preauth() {
	if [ -z ${GOOGLE_APPLICATION_CREDENTIALS+x} ]; then
		gcloud config set project "$GOOGLE_PROJECT"
		if ! gcloud auth application-default print-access-token > /dev/null 2>&1; then
			gcloud auth application-default login
			if ! gcloud auth application-default print-access-token > /dev/null; then
				echo >&2 "Google login failed!"
				return 1
			fi
		fi
	fi
	local env
	if ! env="$(
		python - <<- "EOF"
			from pathlib import Path
			import sys
			import botocore.session
			import botocore.credentials

			# Get the AssumeRole credential provider and make it the only one
			session = botocore.session.get_session()
			resolver = session.get_component('credential_provider')
			assume_role_provider = resolver.get_provider('assume-role')
			resolver.providers = [assume_role_provider]

			# Make the provider use the same cache as the AWS CLI
			cli_cache = Path('~', '.aws', 'cli', 'cache').expanduser()
			assume_role_provider.cache = botocore.credentials.JSONFileCache(cli_cache)

			# Request the credentials. If the CLI has cached credentials, this step
			# would use those. If not, fresh ones will be requested from STS. If that
			# requires entering an MFA code, the user will be prompted. The fresh
			# credentials will be cached such that subsequent invocations just use them
			# until they expire.
			credentials = session.get_credentials()

			# Print the bash statement so they can be eval-ed
			print(f'export AWS_ACCESS_KEY_ID={credentials.access_key}')
			print(f'export AWS_SECRET_ACCESS_KEY={credentials.secret_key}')
			print(f'export AWS_SESSION_TOKEN={credentials.token}')
		EOF
	)"; then
		echo >&2 "AWS login failed!"
		return 2
	fi
	eval "$env"
	echo >&2
	echo >&2 "Temporary session credentials are in effect for AWS and Google." \
		"Use '_deauth' to revert the effect of this command."
	echo >&2
	return 0
}

_deauth() {
	unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
	echo >&2
	echo >&2 "Revoked temporary AWS credentials."
	echo >&2
	if [ -z ${GOOGLE_APPLICATION_CREDENTIALS+x} ]; then
		echo >&2
		echo >&2 "Google Cloud application default credentials are system-global." \
			"You should revoke the existing credentials unless you are *certain* that" \
			"you are already logged in using the appropriate account and project." \
			"If in doubt, enter 'y'."
		echo >&2
		gcloud auth application-default revoke
		echo >&2
		echo >&2 "Revoked temporary Google credentials."
		echo >&2
	fi
}

_revenv() {
	deactivate && make virtualenv && source .venv/bin/activate && make requirements envhook
}

# We disable `envhook.py` to avoid redundancy. The `envhook.py` script imports
# `export_environment.py`, too. We could also pass -S to `python3` but that
# causes problems on Travis (`importlib.util` failing to import `contextlib`).
#
eval "$(ENVHOOK=0 python3 "${project_root}/scripts/export_environment.py" || echo false)"

# Auto-completion for _select
#
_complete_env() {
	# https://stuff-things.net/2016/05/11/bash-autocompletion/
	local env envs
	env="${COMP_WORDS[COMP_CWORD]}"
	# * because of https://unix.stackexchange.com/a/537241/448602
	envs=$(find "${project_root}/deployments" -maxdepth 1 -type d -print0 | xargs -0 basename)
	# shellcheck disable=SC2207
	COMPREPLY=($(compgen -W "$envs" -- "${env}"))
	return 0
}

complete -F _complete_env _select
