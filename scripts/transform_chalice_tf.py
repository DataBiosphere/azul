from argparse import ArgumentParser
import json
import sys


def transform_tf(input_json):
    # TODO: After #1450 is merged, we can integrate the spec manually into the
    # Terraform generated by Chalice. This would allow more fine grained control
    # of what API Gateway makes available. Also see what TF says about
    # template_file https://www.terraform.io/docs/providers/template/d/file.html

    assert 'variable' not in input_json
    input_json['variable'] = {'role_arn': {}}

    input_json['output']['rest_api_id'] = {
        'value': '${aws_api_gateway_rest_api.rest_api.id}'
    }

    for func in input_json['resource']['aws_lambda_function'].values():
        assert func['source_code_hash'] == '${filebase64sha256("./deployment.zip")}'
        func['source_code_hash'] = '${filebase64sha256("${path.module}/deployment.zip")}'
        assert func['filename'] == "./deployment.zip"
        func['filename'] = "${path.module}/deployment.zip"

    # TODO: Remove when https://github.com/aws/chalice/issues/1237 is merged
    assert 'lifecycle' not in input_json['resource']['aws_api_gateway_deployment']['rest_api']
    input_json['resource']['aws_api_gateway_deployment']['rest_api']['lifecycle'] = {'create_before_destroy': True}

    return input_json


def main(argv):
    parser = ArgumentParser(
        description='Transform Chalice generated Terraform so that it can be '
                    'integrated with Azul.'
    )
    parser.add_argument('source', help='the input Terraform file to be transformed')
    parser.add_argument('dest', help='where the transformed file is written')
    options = parser.parse_args(argv)
    with open(options.source, 'r') as f:
        output_json = json.load(f)
    output_json = transform_tf(output_json)
    with open(options.dest, 'w') as f:
        json.dump(output_json, f, indent=4)


if __name__ == '__main__':
    main(sys.argv[1:])
